#!/usr/bin/env python2

import os
import sys
import re
import datetime
import struct
import subprocess
import hashlib
import binascii
import shutil

""" Default / Architectural Options """

ARCHITECTURE = "amd64"

PAGESIZE = 4096
MEMORY_GAP = PAGESIZE

TCSSIZE = PAGESIZE
SSAFRAMESIZE = PAGESIZE
SSAFRAMENUM = 2

ENCLAVE_STACK_SIZE = PAGESIZE * 128
DEFAULT_ENCLAVE_SIZE = '64G'
DEFAULT_THREAD_NUM = 4
ENCLAVE_HEAP_MIN = 0x10000

""" Utilities """

def roundup(addr):
    remaining = addr % PAGESIZE
    if remaining:
        return addr + (PAGESIZE - remaining)
    else:
        return addr

def rounddown(addr):
    return addr - addr % PAGESIZE

def roundup_data(data):
    return data + '\0' * (roundup(len(data)) - len(data))

def int_to_bytes(i):
    b = ""
    l = 0
    while i > 0:
        b = b + chr(i % 256)
        i = i // 256
        l = l + 1
    return b

def bytes_to_int(b):
    i = 0
    for c in b:
        i = i * 256 + ord(c)
    return i

def parse_int(s):
    if len(s) > 2 and s.startswith("0x"):
        return int(s[2:], 16)
    if len(s) > 1 and s.startswith("0"):
        return int(s[1:], 8)
    return int(s)

def parse_size(s):
    scale = 1
    if s.endswith("K"):
        scale = 1024
    if s.endswith("M"):
        scale = 1024 * 1024
    if s.endswith("G"):
        scale = 1024 * 1024 * 1024
    if scale != 1:
        s = s[:-1]
    return parse_int(s) * scale


""" Reading / Writing Manifests """

def read_manifest(filename):
    manifest = dict()
    manifest_layout = []
    with open(filename, "r") as f:
        for line in f.readlines():
            if line == "":
                manifest_layout.append((None, None))
                break

            pound = line.find("#")
            if pound != -1:
                comment = line[pound:].strip()
                line = line[:pound]
            else:
                comment = None

            line = line.strip()
            equal = line.find("=")
            if equal != -1:
                key = line[:equal].strip()
                manifest[key] = line[equal + 1:].strip()
            else:
                key = None

            manifest_layout.append((key, comment))

    return (manifest, manifest_layout)

def output_manifest(filename, manifest, manifest_layout):
    with open(filename, 'w') as f:
        written = []

        for (key, comment) in manifest_layout:
            line = ''
            if key is not None:
                line += key + ' = ' + manifest[key]
                written.append(key)
            if comment is not None:
                if line != '':
                    line += ' '
                line += comment
            print >>f, line

        print >>f
        print >>f, "# Generated by Graphene"
        print >>f

        for key in sorted(manifest.keys()):
            if key not in written:
                print >>f, key, '=', manifest[key]


""" Loading Enclave Attributes """

def get_enclave_attributes(manifest):
    sgx_flags = {
        'FLAG_DEBUG'          : struct.pack("<Q", 0x02),
        'FLAG_MODE64BIT'      : struct.pack("<Q", 0x04),
    }

    sgx_xfrms = {
        'XFRM_LEGACY'         : struct.pack("<Q", 0x03),
        'XFRM_AVX'            : struct.pack("<Q", 0x06),
        'XFRM_AVX3'           : struct.pack("<Q", 0xe6),
        'XFRM_MPX'            : struct.pack("<Q", 0x18),
    }

    sgx_miscs = {
        'MISC_EXINFO'         : struct.pack("<L", 0x01),
    }

    default_attributes = [
        'FLAG_MODE64BIT',
        'FLAG_DEBUG',
        'XFRM_LEGACY',
        'XFRM_AVX',
    ]

    if ARCHITECTURE == 'amd64':
        default_attributes.append('FLAG_MODE64BIT')

    manifest_options = {
        'debug'          : 'FLAG_DEBUG',
        'enable_avx3'    : 'XFRM_AVX3',
        'enable_mpx'     : 'XFRM_MPX',
        'support_exinfo' : 'MISC_EXINFO',
    }

    attributes = default_attributes

    '''
    for opt in manifest_options.keys():
        key = 'sgx.' + opt
        if key in manifest:
            if manifest[key] == '1':
                attributes.append(manifest_options[opt])
            else:
                if manifest_options[opt] in attributes:
                    attributes.pop(manifest_options[opt])

    if manifest.get('sgx.disable_avx') == '1':
      attributes.remove('XFRM_AVX')
    '''
    flags_raw = struct.pack("<Q", 0)
    xfrms_raw = struct.pack("<Q", 0)
    miscs_raw = struct.pack("<L", 0)

    for attr in attributes:
        if attr in sgx_flags:
            flags_raw = ''.join([chr(ord(a)|ord(b)) for a, b in zip(flags_raw, sgx_flags[attr])])
        if attr in sgx_xfrms:
            xfrms_raw = ''.join([chr(ord(a)|ord(b)) for a, b in zip(xfrms_raw, sgx_xfrms[attr])])
        if attr in sgx_miscs:
            miscs_raw = ''.join([chr(ord(a)|ord(b)) for a, b in zip(miscs_raw, sgx_miscs[attr])])

    return flags_raw, xfrms_raw, miscs_raw


""" Generate Checksums / Measurement """

def resolve_uri(uri, check_exist=True):
    orig_uri = uri
    if uri.startswith('file:'):
        print(uri)
        target = os.path.normpath(uri[5:])
    else:
        target = os.path.normpath(uri)
    if check_exist and not os.path.exists(target):
        raise Exception('Cannot resolve ' + orig_uri + ' or the file does not exist.')
    return target

def get_checksum(file):
    digest = hashlib.sha256()
    with open(file, 'rb') as f:
        digest.update(f.read())
    return digest.digest()

def get_trusted_files(manifest, args):
    targets = dict()

    if 'exec' in args: # mkpark
        targets['exec'] = (args['exec'], resolve_uri(args['exec']))

    if 'loader.preload' in manifest:
        i = 0
        preloads = []
        for uri in str.split(manifest['loader.preload'], ','):
            targets['preload' + str(i)] = (uri, resolve_uri(uri))
            preloads.append(uri)
            i += 1

    for (key, val) in manifest.items():
        if not key.startswith('sgx.trusted_files.'):
            continue
        key = key[len('sgx.trusted_files.'):]
        if key in targets:
            raise Exception('repeated key in manifest: sgx.trusted_files.' + key)
        targets[key] = (val, resolve_uri(val))

    for (key, val) in targets.items():
        (uri, target) = val
        checksum = get_checksum(target).encode('hex')
        targets[key] = (uri, target, checksum)

    return targets

def get_trusted_children(manifest, args):
    targets = dict()

    for (key, val) in manifest.items():
        if not key.startswith('sgx.trusted_children.'):
            continue
        key = key[len('sgx.trusted_children.'):]
        if key in targets:
            raise Exception('repeated key in manifest: sgx.trusted_children.' + key)

        target = resolve_uri(val)
        sig = open(target, 'rb').read()[960:992].encode('hex')
        targets[key] = (val, target, sig)

    return targets

""" Populate Enclave Memory """

PAGEINFO_R = 0x1
PAGEINFO_W = 0x2
PAGEINFO_X = 0x4
PAGEINFO_TCS = 0x100
PAGEINFO_UNVAL = 0x1000
PAGEINFO_REG = 0x200

def get_loadcmds(filename):
    loadcmds = []
    p = subprocess.Popen(['readelf', '-l', '-W', filename],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
    while True:
        line = p.stdout.readline()
        if line == '':
            break
        stripped = line.strip()
        if not stripped.startswith('LOAD'):
            continue
        tokens = stripped.split()
        if len(tokens) < 6:
            continue
        if len(tokens) >= 7 and tokens[7] == "E":
            tokens[6] += tokens[7]
        prot = 0
        for t in tokens[6]:
            if t == "R":
                prot = prot | 4
            if t == "W":
                prot = prot | 2
            if t == "E":
                prot = prot | 1

        loadcmds.append((int(tokens[1][2:], 16),  # offset
                         int(tokens[2][2:], 16),  # addr
                         int(tokens[4][2:], 16),  # filesize
                         int(tokens[5][2:], 16),  # memsize
                         prot))
    p.wait()
    if p.returncode != 0:
        return None
    return loadcmds

class MemoryArea:
    def __init__(self, desc, file=None, addr=None, size=None, flags=None):
        self.desc = desc
        self.file = file
        self.addr = addr
        self.size = size
        self.flags = flags
        self.is_binary = False

        if file:
            loadcmds = get_loadcmds(file)
            print loadcmds
            if loadcmds:
                mapaddr = 0xffffffffffffffff
                mapaddr_end = 0
                for (offset, addr, filesize, memsize, prot) in loadcmds:
                    if rounddown(addr) < mapaddr:
                        mapaddr = rounddown(addr)
                    if roundup(addr + memsize) > mapaddr_end:
                        mapaddr_end = roundup(addr + memsize)

                self.is_binary = True
                self.size = mapaddr_end - mapaddr
                if mapaddr >= 0:
                    self.addr = mapaddr
            else:
                self.size = os.stat(file).st_size

        if self.addr is not None:
            self.addr = rounddown(self.addr)
        if self.size is not None:
            self.size = roundup(self.size)

NACL_MAP_PAGESIZE = 65536

#syseok : for page allocation
def NaClTruncAllocPage(nbytes) :
  return nbytes & ~(NACL_MAP_PAGESIZE - 1);


def get_memory_areas(attr, args): # manifest, attr, args):
    areas = []

    # untrusted area: 4GG
    addr_base = 0x100000000 
    # NACL_TRAMPOLINE_START (==1<NACL_NULL_REGION_SHIFT; null area)
    addr_tramp_start = 0x10000
    size =  0x10000 # NACL_TRAMPOLINE_SIZE
    areas.append(MemoryArea('trampoline', size=size,
                            flags=PAGEINFO_R|PAGEINFO_X|PAGEINFO_REG, addr = addr_base + addr_tramp_start))


    # Executable module's LOAD segments
    loadlist = get_loadcmds(args['exec'])
    segnum=0
    # index: offset, addr, filesz, memsz, flags 
    for segments in loadlist:
        size = segments[0]+segments[3]-NaClTruncAllocPage(segments[0])
        size = ((size/PAGESIZE)+1)*PAGESIZE

        flag = PAGEINFO_REG        
        flags = segments[4]
        if(flags&4):
            flag= flag|PAGEINFO_R
        if(flags&2):
            flag=flag|PAGEINFO_W
        if(flags&1):
            flag=flag|PAGEINFO_X

        areas.append(MemoryArea("exec" + str(segnum), size = size,
                            flags = flag, 
                            addr = addr_base + NaClTruncAllocPage(segments[1])))                    
        segnum += 1

    hole_start = 0x1f0000000;
    stack_start = 0x1ff000000;
    areas.append(MemoryArea('hole', size = stack_start - hole_start,
        flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, 
        addr = hole_start));
  
    areas.append(MemoryArea('exec_stack', size= 0x1000000, 
        flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, 
        addr = stack_start))


    size = (int((os.path.getsize(args['libsel']))/TCSSIZE)+1)*TCSSIZE

    addr_index = 48*1024*1024*1024

    print("libsel size is "+str(size))
    areas.append(MemoryArea('libsel', file=args['libsel'], 
        flags=PAGEINFO_REG, addr = addr_index))
    addr_index += 0x20000000

    size = ENCLAVE_STACK_SIZE
    for t in range(attr['thread_num']):
        areas.append(MemoryArea('stack', size= size,
                            flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, 
                            addr = addr_index))                    
        addr_index += size

    
    size = size=attr['thread_num'] * PAGESIZE
    areas.append(MemoryArea('tls', size=size,
                           flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, addr = addr_index))
    addr_index += size


    size = attr['thread_num'] * TCSSIZE # TCSSIZE == PAGESIZE
    areas.append(MemoryArea('tcs', size = size,
                            flags = PAGEINFO_TCS, addr = addr_index))
    addr_index += size

    size = attr['thread_num'] * SSAFRAMESIZE * SSAFRAMENUM
    areas.append(MemoryArea('ssa', size = size,
                            flags = PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG, addr = addr_index))
    addr_index += size

    # 
    #     areas.append(MemoryArea('stack', size=ENCLAVE_STACK_SIZE,
    #                             flags=PAGEINFO_R|PAGEINFO_W|PAGEINFO_REG))

    # areas.append(MemoryArea('pal', file=args['libpal'], flags=PAGEINFO_REG))

    # if 'exec' in args:
    #     areas.append(MemoryArea('exec', file=args['exec'],
    #                             flags=PAGEINFO_W|PAGEINFO_REG))
    # return areas
    return areas


